// These constants represent the RISC-V ELF and the image ID generated by risc0-build.
// The ELF is used for proving and the ID is used for verification.
use methods::{
    FHE_ELF, FHE_ID
};
use risc0_zkvm::{default_prover, ExecutorEnv};
use tfhe::boolean::{prelude::*, gen_keys};

fn main() {
    // Initialize tracing. In order to view logs, run `RUST_LOG=info cargo run`
    tracing_subscriber::fmt()
        .with_env_filter(tracing_subscriber::filter::EnvFilter::from_default_env())
        .init();

    // An executor environment describes the configurations for the zkVM
    // including program inputs.
    // An default ExecutorEnv can be created like so:
    // `let env = ExecutorEnv::builder().build().unwrap();`
    // However, this `env` does not have any inputs.
    //
    // To add guest input to the executor environment, use
    // ExecutorEnvBuilder::write().
    // To access this method, you'll need to use ExecutorEnv::builder(), which
    // creates an ExecutorEnvBuilder. When you're done adding input, call
    // ExecutorEnvBuilder::build().

    // let config = ConfigBuilder::default().build();
    let (client_key, server_key) = gen_keys();

    let clear_a = true;
    let clear_b = false;

    let enc_a = client_key.encrypt(true);
    let enc_b = client_key.encrypt(false);
    // let enc_a = FheBool::try_encrypt(clear_a, &client_key).unwrap();
    // let enc_b = FheBool::try_encrypt(clear_b, &client_key).unwrap();

    // let compressed_key = CompressedServerKey::new(&client_key);

    let server_key_bin = bincode::serialize(&server_key).unwrap();
    println!("Compressed Server bin key is {} bytes", server_key_bin.len());
    let env_a_bin = bincode::serialize(&enc_a).unwrap();
    println!("Compressed bin ciphertext A is {} bytes", env_a_bin.len());
    let env_b_bin = bincode::serialize(&enc_b).unwrap();
    println!("Compressed bin ciphertext B is {} bytes", env_b_bin.len());
    // return;
    //
    // // // For example:
    // // let raw_key = server_key.into_raw_parts();
    // // // let raw_key_bin = bincode::encode_to_vec(&raw_key, Configuration::default());
    // // let raw_key_bin = bincode::serialize(&raw_key).unwrap();
    // // println!("Raw bin key is {} bytes", raw_key_bin.len());
    //
    // let env = ExecutorEnv::builder()
    //     // .write(&raw_key.0).unwrap()
    //     // .write(&raw_key.1).unwrap()
    //     // .write(&raw_key_bin).unwrap()
    //     .write(&server_key).unwrap()
    //     .write(&enc_a).unwrap()
    //     .write(&enc_b).unwrap()
    //     .build()
    //     .unwrap();
    //
    // // Obtain the default prover.
    // let prover = default_prover();
    //
    // // Proof information by proving the specified ELF binary.
    // // This struct contains the receipt along with statistics about execution of the guest
    // let prove_info = prover
    //     .prove(env, FHE_ELF)
    //     .unwrap();
    //
    // // extract the receipt.
    // let receipt = prove_info.receipt;
    //
    // // For example:
    // let output: FheUint32 = receipt.journal.decode().unwrap();
    //
    // let dec_output: u32 = output.decrypt(&client_key);
    //
    // assert_eq!(dec_output, clear_a * clear_b);
    //
    // // The receipt was verified at the end of proving, but the below code is an
    // // example of how someone else could verify this receipt.
    // receipt
    //     .verify(FHE_ID)
    //     .unwrap();
}
